/* 
 * Argo
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v2.4.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.IO;
using System.Linq;
using System.Runtime.Serialization;
using System.Text;
using Newtonsoft.Json;

namespace AutoDeploy.ArgoSupport.Workflows.Model
{
    /// <summary>
    /// WorkflowSpec is the specification of a Workflow.
    /// </summary>
    [DataContract]
    public partial class ArgoWorkflowSpec :  IEquatable<ArgoWorkflowSpec>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ArgoWorkflowSpec" /> class.
        /// </summary>
        [JsonConstructor]
        protected ArgoWorkflowSpec() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="ArgoWorkflowSpec" /> class.
        /// </summary>
        /// <param name="activeDeadlineSeconds">Optional duration in seconds relative to the workflow start time which the workflow is allowed to run before the controller terminates the workflow. A value of zero is used to terminate a Running workflow.</param>
        /// <param name="affinity">Affinity sets the scheduling constraints for all pods in the workflow. Can be overridden by an affinity specified in the template.</param>
        /// <param name="arguments">Arguments contain the parameters and artifacts sent to the workflow entrypoint Parameters are referencable globally using the &#39;workflow&#39; variable prefix. e.g. {{workflow.parameters.myparam}}.</param>
        /// <param name="artifactRepositoryRef">ArtifactRepositoryRef specifies the configMap name and key containing the artifact repository config..</param>
        /// <param name="dnsConfig">PodDNSConfig defines the DNS parameters of a pod in addition to those generated from DNSPolicy..</param>
        /// <param name="dnsPolicy">Set DNS policy for the pod. Defaults to \&quot;ClusterFirst\&quot;. Valid values are &#39;ClusterFirstWithHostNet&#39;, &#39;ClusterFirst&#39;, &#39;Default&#39; or &#39;None&#39;. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to &#39;ClusterFirstWithHostNet&#39;..</param>
        /// <param name="entrypoint">Entrypoint is a template reference to the starting point of the workflow (required).</param>
        /// <param name="hostAliases">HostAliases is an optional list of hosts and IPs that will be injected into the pod spec.</param>
        /// <param name="hostNetwork">Host networking requested for this workflow pod. Default to false..</param>
        /// <param name="imagePullSecrets">ImagePullSecrets is a list of references to secrets in the same namespace to use for pulling any images in pods that reference this ServiceAccount. ImagePullSecrets are distinct from Secrets because Secrets can be mounted in the pod, but ImagePullSecrets are only accessed by the kubelet. More info: https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod.</param>
        /// <param name="nodeSelector">NodeSelector is a selector which will result in all pods of the workflow to be scheduled on the selected node(s). This is able to be overridden by a nodeSelector specified in the template..</param>
        /// <param name="onExit">OnExit is a template reference which is invoked at the end of the workflow, irrespective of the success, failure, or error of the primary workflow..</param>
        /// <param name="parallelism">Parallelism limits the max total parallel pods that can execute at the same time in a workflow.</param>
        /// <param name="podGC">PodGC describes the strategy to use when to deleting completed pods.</param>
        /// <param name="podPriority">Priority to apply to workflow pods..</param>
        /// <param name="podPriorityClassName">PriorityClassName to apply to workflow pods..</param>
        /// <param name="priority">Priority is used if controller is configured to process limited number of workflows in parallel. Workflows with higher priority are processed first..</param>
        /// <param name="schedulerName">Set scheduler name for all pods. Will be overridden if container/script template&#39;s scheduler name is set. Default scheduler will be used if neither specified..</param>
        /// <param name="securityContext">SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults to empty.  See type description for default values of each field..</param>
        /// <param name="serviceAccountName">ServiceAccountName is the name of the ServiceAccount to run all pods of the workflow as..</param>
        /// <param name="suspend">Suspend will suspend the workflow and prevent execution of any future steps in the workflow.</param>
        /// <param name="templates">Templates is a list of workflow templates used in a workflow (required).</param>
        /// <param name="tolerations">Tolerations to apply to workflow pods..</param>
        /// <param name="ttlSecondsAfterFinished">TTLSecondsAfterFinished limits the lifetime of a Workflow that has finished execution (Succeeded, Failed, Error). If this field is set, once the Workflow finishes, it will be deleted after ttlSecondsAfterFinished expires. If this field is unset, ttlSecondsAfterFinished will not expire. If this field is set to zero, ttlSecondsAfterFinished expires immediately after the Workflow finishes..</param>
        /// <param name="volumeClaimTemplates">VolumeClaimTemplates is a list of claims that containers are allowed to reference. The Workflow controller will create the claims at the beginning of the workflow and delete the claims upon completion of the workflow.</param>
        /// <param name="volumes">Volumes is a list of volumes that can be mounted by containers in a workflow..</param>
        public ArgoWorkflowSpec(long? activeDeadlineSeconds = default(long?), k8s.Models.V1Affinity affinity = default(k8s.Models.V1Affinity), ArgoArguments arguments = default(ArgoArguments), ArgoArtifactRepositoryRef artifactRepositoryRef = default(ArgoArtifactRepositoryRef), k8s.Models.V1PodDNSConfig dnsConfig = default(k8s.Models.V1PodDNSConfig), string dnsPolicy = default(string), string entrypoint = default(string), List<k8s.Models.V1HostAlias> hostAliases = default(List<k8s.Models.V1HostAlias>), bool? hostNetwork = default(bool?), List<k8s.Models.V1LocalObjectReference> imagePullSecrets = default(List<k8s.Models.V1LocalObjectReference>), Dictionary<string, string> nodeSelector = default(Dictionary<string, string>), string onExit = default(string), long? parallelism = default(long?), ArgoPodGC podGC = default(ArgoPodGC), int? podPriority = default(int?), string podPriorityClassName = default(string), int? priority = default(int?), string schedulerName = default(string), k8s.Models.V1PodSecurityContext securityContext = default(k8s.Models.V1PodSecurityContext), string serviceAccountName = default(string), bool? suspend = default(bool?), List<ArgoTemplate> templates = default(List<ArgoTemplate>), List<k8s.Models.V1Toleration> tolerations = default(List<k8s.Models.V1Toleration>), int? ttlSecondsAfterFinished = default(int?), List<k8s.Models.V1PersistentVolumeClaim> volumeClaimTemplates = default(List<k8s.Models.V1PersistentVolumeClaim>), List<k8s.Models.V1Volume> volumes = default(List<k8s.Models.V1Volume>))
        {
            // to ensure "entrypoint" is required (not null)
            if (entrypoint == null)
            {
                throw new InvalidDataException("entrypoint is a required property for ArgoWorkflowSpec and cannot be null");
            }
            else
            {
                this.Entrypoint = entrypoint;
            }
            // to ensure "templates" is required (not null)
            if (templates == null)
            {
                throw new InvalidDataException("templates is a required property for ArgoWorkflowSpec and cannot be null");
            }
            else
            {
                this.Templates = templates;
            }
            this.ActiveDeadlineSeconds = activeDeadlineSeconds;
            this.Affinity = affinity;
            this.Arguments = arguments;
            this.ArtifactRepositoryRef = artifactRepositoryRef;
            this.DnsConfig = dnsConfig;
            this.DnsPolicy = dnsPolicy;
            this.HostAliases = hostAliases;
            this.HostNetwork = hostNetwork;
            this.ImagePullSecrets = imagePullSecrets;
            this.NodeSelector = nodeSelector;
            this.OnExit = onExit;
            this.Parallelism = parallelism;
            this.PodGC = podGC;
            this.PodPriority = podPriority;
            this.PodPriorityClassName = podPriorityClassName;
            this.Priority = priority;
            this.SchedulerName = schedulerName;
            this.SecurityContext = securityContext;
            this.ServiceAccountName = serviceAccountName;
            this.Suspend = suspend;
            this.Tolerations = tolerations;
            this.TtlSecondsAfterFinished = ttlSecondsAfterFinished;
            this.VolumeClaimTemplates = volumeClaimTemplates;
            this.Volumes = volumes;
        }
        
        /// <summary>
        /// Optional duration in seconds relative to the workflow start time which the workflow is allowed to run before the controller terminates the workflow. A value of zero is used to terminate a Running workflow
        /// </summary>
        /// <value>Optional duration in seconds relative to the workflow start time which the workflow is allowed to run before the controller terminates the workflow. A value of zero is used to terminate a Running workflow</value>
        [DataMember(Name="activeDeadlineSeconds", EmitDefaultValue=false)]
        public long? ActiveDeadlineSeconds { get; set; }

        /// <summary>
        /// Affinity sets the scheduling constraints for all pods in the workflow. Can be overridden by an affinity specified in the template
        /// </summary>
        /// <value>Affinity sets the scheduling constraints for all pods in the workflow. Can be overridden by an affinity specified in the template</value>
        [DataMember(Name="affinity", EmitDefaultValue=false)]
        public k8s.Models.V1Affinity Affinity { get; set; }

        /// <summary>
        /// Arguments contain the parameters and artifacts sent to the workflow entrypoint Parameters are referencable globally using the &#39;workflow&#39; variable prefix. e.g. {{workflow.parameters.myparam}}
        /// </summary>
        /// <value>Arguments contain the parameters and artifacts sent to the workflow entrypoint Parameters are referencable globally using the &#39;workflow&#39; variable prefix. e.g. {{workflow.parameters.myparam}}</value>
        [DataMember(Name="arguments", EmitDefaultValue=false)]
        public ArgoArguments Arguments { get; set; }

        /// <summary>
        /// ArtifactRepositoryRef specifies the configMap name and key containing the artifact repository config.
        /// </summary>
        /// <value>ArtifactRepositoryRef specifies the configMap name and key containing the artifact repository config.</value>
        [DataMember(Name="artifactRepositoryRef", EmitDefaultValue=false)]
        public ArgoArtifactRepositoryRef ArtifactRepositoryRef { get; set; }

        /// <summary>
        /// PodDNSConfig defines the DNS parameters of a pod in addition to those generated from DNSPolicy.
        /// </summary>
        /// <value>PodDNSConfig defines the DNS parameters of a pod in addition to those generated from DNSPolicy.</value>
        [DataMember(Name="dnsConfig", EmitDefaultValue=false)]
        public k8s.Models.V1PodDNSConfig DnsConfig { get; set; }

        /// <summary>
        /// Set DNS policy for the pod. Defaults to \&quot;ClusterFirst\&quot;. Valid values are &#39;ClusterFirstWithHostNet&#39;, &#39;ClusterFirst&#39;, &#39;Default&#39; or &#39;None&#39;. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to &#39;ClusterFirstWithHostNet&#39;.
        /// </summary>
        /// <value>Set DNS policy for the pod. Defaults to \&quot;ClusterFirst\&quot;. Valid values are &#39;ClusterFirstWithHostNet&#39;, &#39;ClusterFirst&#39;, &#39;Default&#39; or &#39;None&#39;. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to &#39;ClusterFirstWithHostNet&#39;.</value>
        [DataMember(Name="dnsPolicy", EmitDefaultValue=false)]
        public string DnsPolicy { get; set; }

        /// <summary>
        /// Entrypoint is a template reference to the starting point of the workflow
        /// </summary>
        /// <value>Entrypoint is a template reference to the starting point of the workflow</value>
        [DataMember(Name="entrypoint", EmitDefaultValue=false)]
        public string Entrypoint { get; set; }

        /// <summary>
        /// HostAliases is an optional list of hosts and IPs that will be injected into the pod spec
        /// </summary>
        /// <value>HostAliases is an optional list of hosts and IPs that will be injected into the pod spec</value>
        [DataMember(Name="hostAliases", EmitDefaultValue=false)]
        public List<k8s.Models.V1HostAlias> HostAliases { get; set; }

        /// <summary>
        /// Host networking requested for this workflow pod. Default to false.
        /// </summary>
        /// <value>Host networking requested for this workflow pod. Default to false.</value>
        [DataMember(Name="hostNetwork", EmitDefaultValue=false)]
        public bool? HostNetwork { get; set; }

        /// <summary>
        /// ImagePullSecrets is a list of references to secrets in the same namespace to use for pulling any images in pods that reference this ServiceAccount. ImagePullSecrets are distinct from Secrets because Secrets can be mounted in the pod, but ImagePullSecrets are only accessed by the kubelet. More info: https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod
        /// </summary>
        /// <value>ImagePullSecrets is a list of references to secrets in the same namespace to use for pulling any images in pods that reference this ServiceAccount. ImagePullSecrets are distinct from Secrets because Secrets can be mounted in the pod, but ImagePullSecrets are only accessed by the kubelet. More info: https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod</value>
        [DataMember(Name="imagePullSecrets", EmitDefaultValue=false)]
        public List<k8s.Models.V1LocalObjectReference> ImagePullSecrets { get; set; }

        /// <summary>
        /// NodeSelector is a selector which will result in all pods of the workflow to be scheduled on the selected node(s). This is able to be overridden by a nodeSelector specified in the template.
        /// </summary>
        /// <value>NodeSelector is a selector which will result in all pods of the workflow to be scheduled on the selected node(s). This is able to be overridden by a nodeSelector specified in the template.</value>
        [DataMember(Name="nodeSelector", EmitDefaultValue=false)]
        public Dictionary<string, string> NodeSelector { get; set; }

        /// <summary>
        /// OnExit is a template reference which is invoked at the end of the workflow, irrespective of the success, failure, or error of the primary workflow.
        /// </summary>
        /// <value>OnExit is a template reference which is invoked at the end of the workflow, irrespective of the success, failure, or error of the primary workflow.</value>
        [DataMember(Name="onExit", EmitDefaultValue=false)]
        public string OnExit { get; set; }

        /// <summary>
        /// Parallelism limits the max total parallel pods that can execute at the same time in a workflow
        /// </summary>
        /// <value>Parallelism limits the max total parallel pods that can execute at the same time in a workflow</value>
        [DataMember(Name="parallelism", EmitDefaultValue=false)]
        public long? Parallelism { get; set; }

        /// <summary>
        /// PodGC describes the strategy to use when to deleting completed pods
        /// </summary>
        /// <value>PodGC describes the strategy to use when to deleting completed pods</value>
        [DataMember(Name="podGC", EmitDefaultValue=false)]
        public ArgoPodGC PodGC { get; set; }

        /// <summary>
        /// Priority to apply to workflow pods.
        /// </summary>
        /// <value>Priority to apply to workflow pods.</value>
        [DataMember(Name="podPriority", EmitDefaultValue=false)]
        public int? PodPriority { get; set; }

        /// <summary>
        /// PriorityClassName to apply to workflow pods.
        /// </summary>
        /// <value>PriorityClassName to apply to workflow pods.</value>
        [DataMember(Name="podPriorityClassName", EmitDefaultValue=false)]
        public string PodPriorityClassName { get; set; }

        /// <summary>
        /// Priority is used if controller is configured to process limited number of workflows in parallel. Workflows with higher priority are processed first.
        /// </summary>
        /// <value>Priority is used if controller is configured to process limited number of workflows in parallel. Workflows with higher priority are processed first.</value>
        [DataMember(Name="priority", EmitDefaultValue=false)]
        public int? Priority { get; set; }

        /// <summary>
        /// Set scheduler name for all pods. Will be overridden if container/script template&#39;s scheduler name is set. Default scheduler will be used if neither specified.
        /// </summary>
        /// <value>Set scheduler name for all pods. Will be overridden if container/script template&#39;s scheduler name is set. Default scheduler will be used if neither specified.</value>
        [DataMember(Name="schedulerName", EmitDefaultValue=false)]
        public string SchedulerName { get; set; }

        /// <summary>
        /// SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults to empty.  See type description for default values of each field.
        /// </summary>
        /// <value>SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults to empty.  See type description for default values of each field.</value>
        [DataMember(Name="securityContext", EmitDefaultValue=false)]
        public k8s.Models.V1PodSecurityContext SecurityContext { get; set; }

        /// <summary>
        /// ServiceAccountName is the name of the ServiceAccount to run all pods of the workflow as.
        /// </summary>
        /// <value>ServiceAccountName is the name of the ServiceAccount to run all pods of the workflow as.</value>
        [DataMember(Name="serviceAccountName", EmitDefaultValue=false)]
        public string ServiceAccountName { get; set; }

        /// <summary>
        /// Suspend will suspend the workflow and prevent execution of any future steps in the workflow
        /// </summary>
        /// <value>Suspend will suspend the workflow and prevent execution of any future steps in the workflow</value>
        [DataMember(Name="suspend", EmitDefaultValue=false)]
        public bool? Suspend { get; set; }

        /// <summary>
        /// Templates is a list of workflow templates used in a workflow
        /// </summary>
        /// <value>Templates is a list of workflow templates used in a workflow</value>
        [DataMember(Name="templates", EmitDefaultValue=false)]
        public List<ArgoTemplate> Templates { get; set; }

        /// <summary>
        /// Tolerations to apply to workflow pods.
        /// </summary>
        /// <value>Tolerations to apply to workflow pods.</value>
        [DataMember(Name="tolerations", EmitDefaultValue=false)]
        public List<k8s.Models.V1Toleration> Tolerations { get; set; }

        /// <summary>
        /// TTLSecondsAfterFinished limits the lifetime of a Workflow that has finished execution (Succeeded, Failed, Error). If this field is set, once the Workflow finishes, it will be deleted after ttlSecondsAfterFinished expires. If this field is unset, ttlSecondsAfterFinished will not expire. If this field is set to zero, ttlSecondsAfterFinished expires immediately after the Workflow finishes.
        /// </summary>
        /// <value>TTLSecondsAfterFinished limits the lifetime of a Workflow that has finished execution (Succeeded, Failed, Error). If this field is set, once the Workflow finishes, it will be deleted after ttlSecondsAfterFinished expires. If this field is unset, ttlSecondsAfterFinished will not expire. If this field is set to zero, ttlSecondsAfterFinished expires immediately after the Workflow finishes.</value>
        [DataMember(Name="ttlSecondsAfterFinished", EmitDefaultValue=false)]
        public int? TtlSecondsAfterFinished { get; set; }

        /// <summary>
        /// VolumeClaimTemplates is a list of claims that containers are allowed to reference. The Workflow controller will create the claims at the beginning of the workflow and delete the claims upon completion of the workflow
        /// </summary>
        /// <value>VolumeClaimTemplates is a list of claims that containers are allowed to reference. The Workflow controller will create the claims at the beginning of the workflow and delete the claims upon completion of the workflow</value>
        [DataMember(Name="volumeClaimTemplates", EmitDefaultValue=false)]
        public List<k8s.Models.V1PersistentVolumeClaim> VolumeClaimTemplates { get; set; }

        /// <summary>
        /// Volumes is a list of volumes that can be mounted by containers in a workflow.
        /// </summary>
        /// <value>Volumes is a list of volumes that can be mounted by containers in a workflow.</value>
        [DataMember(Name="volumes", EmitDefaultValue=false)]
        public List<k8s.Models.V1Volume> Volumes { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class ArgoWorkflowSpec {\n");
            sb.Append("  ActiveDeadlineSeconds: ").Append(ActiveDeadlineSeconds).Append("\n");
            sb.Append("  Affinity: ").Append(Affinity).Append("\n");
            sb.Append("  Arguments: ").Append(Arguments).Append("\n");
            sb.Append("  ArtifactRepositoryRef: ").Append(ArtifactRepositoryRef).Append("\n");
            sb.Append("  DnsConfig: ").Append(DnsConfig).Append("\n");
            sb.Append("  DnsPolicy: ").Append(DnsPolicy).Append("\n");
            sb.Append("  Entrypoint: ").Append(Entrypoint).Append("\n");
            sb.Append("  HostAliases: ").Append(HostAliases).Append("\n");
            sb.Append("  HostNetwork: ").Append(HostNetwork).Append("\n");
            sb.Append("  ImagePullSecrets: ").Append(ImagePullSecrets).Append("\n");
            sb.Append("  NodeSelector: ").Append(NodeSelector).Append("\n");
            sb.Append("  OnExit: ").Append(OnExit).Append("\n");
            sb.Append("  Parallelism: ").Append(Parallelism).Append("\n");
            sb.Append("  PodGC: ").Append(PodGC).Append("\n");
            sb.Append("  PodPriority: ").Append(PodPriority).Append("\n");
            sb.Append("  PodPriorityClassName: ").Append(PodPriorityClassName).Append("\n");
            sb.Append("  Priority: ").Append(Priority).Append("\n");
            sb.Append("  SchedulerName: ").Append(SchedulerName).Append("\n");
            sb.Append("  SecurityContext: ").Append(SecurityContext).Append("\n");
            sb.Append("  ServiceAccountName: ").Append(ServiceAccountName).Append("\n");
            sb.Append("  Suspend: ").Append(Suspend).Append("\n");
            sb.Append("  Templates: ").Append(Templates).Append("\n");
            sb.Append("  Tolerations: ").Append(Tolerations).Append("\n");
            sb.Append("  TtlSecondsAfterFinished: ").Append(TtlSecondsAfterFinished).Append("\n");
            sb.Append("  VolumeClaimTemplates: ").Append(VolumeClaimTemplates).Append("\n");
            sb.Append("  Volumes: ").Append(Volumes).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as ArgoWorkflowSpec);
        }

        /// <summary>
        /// Returns true if ArgoWorkflowSpec instances are equal
        /// </summary>
        /// <param name="input">Instance of ArgoWorkflowSpec to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(ArgoWorkflowSpec input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.ActiveDeadlineSeconds == input.ActiveDeadlineSeconds ||
                    (this.ActiveDeadlineSeconds != null &&
                    this.ActiveDeadlineSeconds.Equals(input.ActiveDeadlineSeconds))
                ) && 
                (
                    this.Affinity == input.Affinity ||
                    (this.Affinity != null &&
                    this.Affinity.Equals(input.Affinity))
                ) && 
                (
                    this.Arguments == input.Arguments ||
                    (this.Arguments != null &&
                    this.Arguments.Equals(input.Arguments))
                ) && 
                (
                    this.ArtifactRepositoryRef == input.ArtifactRepositoryRef ||
                    (this.ArtifactRepositoryRef != null &&
                    this.ArtifactRepositoryRef.Equals(input.ArtifactRepositoryRef))
                ) && 
                (
                    this.DnsConfig == input.DnsConfig ||
                    (this.DnsConfig != null &&
                    this.DnsConfig.Equals(input.DnsConfig))
                ) && 
                (
                    this.DnsPolicy == input.DnsPolicy ||
                    (this.DnsPolicy != null &&
                    this.DnsPolicy.Equals(input.DnsPolicy))
                ) && 
                (
                    this.Entrypoint == input.Entrypoint ||
                    (this.Entrypoint != null &&
                    this.Entrypoint.Equals(input.Entrypoint))
                ) && 
                (
                    this.HostAliases == input.HostAliases ||
                    this.HostAliases != null &&
                    this.HostAliases.SequenceEqual(input.HostAliases)
                ) && 
                (
                    this.HostNetwork == input.HostNetwork ||
                    (this.HostNetwork != null &&
                    this.HostNetwork.Equals(input.HostNetwork))
                ) && 
                (
                    this.ImagePullSecrets == input.ImagePullSecrets ||
                    this.ImagePullSecrets != null &&
                    this.ImagePullSecrets.SequenceEqual(input.ImagePullSecrets)
                ) && 
                (
                    this.NodeSelector == input.NodeSelector ||
                    this.NodeSelector != null &&
                    this.NodeSelector.SequenceEqual(input.NodeSelector)
                ) && 
                (
                    this.OnExit == input.OnExit ||
                    (this.OnExit != null &&
                    this.OnExit.Equals(input.OnExit))
                ) && 
                (
                    this.Parallelism == input.Parallelism ||
                    (this.Parallelism != null &&
                    this.Parallelism.Equals(input.Parallelism))
                ) && 
                (
                    this.PodGC == input.PodGC ||
                    (this.PodGC != null &&
                    this.PodGC.Equals(input.PodGC))
                ) && 
                (
                    this.PodPriority == input.PodPriority ||
                    (this.PodPriority != null &&
                    this.PodPriority.Equals(input.PodPriority))
                ) && 
                (
                    this.PodPriorityClassName == input.PodPriorityClassName ||
                    (this.PodPriorityClassName != null &&
                    this.PodPriorityClassName.Equals(input.PodPriorityClassName))
                ) && 
                (
                    this.Priority == input.Priority ||
                    (this.Priority != null &&
                    this.Priority.Equals(input.Priority))
                ) && 
                (
                    this.SchedulerName == input.SchedulerName ||
                    (this.SchedulerName != null &&
                    this.SchedulerName.Equals(input.SchedulerName))
                ) && 
                (
                    this.SecurityContext == input.SecurityContext ||
                    (this.SecurityContext != null &&
                    this.SecurityContext.Equals(input.SecurityContext))
                ) && 
                (
                    this.ServiceAccountName == input.ServiceAccountName ||
                    (this.ServiceAccountName != null &&
                    this.ServiceAccountName.Equals(input.ServiceAccountName))
                ) && 
                (
                    this.Suspend == input.Suspend ||
                    (this.Suspend != null &&
                    this.Suspend.Equals(input.Suspend))
                ) && 
                (
                    this.Templates == input.Templates ||
                    this.Templates != null &&
                    this.Templates.SequenceEqual(input.Templates)
                ) && 
                (
                    this.Tolerations == input.Tolerations ||
                    this.Tolerations != null &&
                    this.Tolerations.SequenceEqual(input.Tolerations)
                ) && 
                (
                    this.TtlSecondsAfterFinished == input.TtlSecondsAfterFinished ||
                    (this.TtlSecondsAfterFinished != null &&
                    this.TtlSecondsAfterFinished.Equals(input.TtlSecondsAfterFinished))
                ) && 
                (
                    this.VolumeClaimTemplates == input.VolumeClaimTemplates ||
                    this.VolumeClaimTemplates != null &&
                    this.VolumeClaimTemplates.SequenceEqual(input.VolumeClaimTemplates)
                ) && 
                (
                    this.Volumes == input.Volumes ||
                    this.Volumes != null &&
                    this.Volumes.SequenceEqual(input.Volumes)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.ActiveDeadlineSeconds != null)
                    hashCode = hashCode * 59 + this.ActiveDeadlineSeconds.GetHashCode();
                if (this.Affinity != null)
                    hashCode = hashCode * 59 + this.Affinity.GetHashCode();
                if (this.Arguments != null)
                    hashCode = hashCode * 59 + this.Arguments.GetHashCode();
                if (this.ArtifactRepositoryRef != null)
                    hashCode = hashCode * 59 + this.ArtifactRepositoryRef.GetHashCode();
                if (this.DnsConfig != null)
                    hashCode = hashCode * 59 + this.DnsConfig.GetHashCode();
                if (this.DnsPolicy != null)
                    hashCode = hashCode * 59 + this.DnsPolicy.GetHashCode();
                if (this.Entrypoint != null)
                    hashCode = hashCode * 59 + this.Entrypoint.GetHashCode();
                if (this.HostAliases != null)
                    hashCode = hashCode * 59 + this.HostAliases.GetHashCode();
                if (this.HostNetwork != null)
                    hashCode = hashCode * 59 + this.HostNetwork.GetHashCode();
                if (this.ImagePullSecrets != null)
                    hashCode = hashCode * 59 + this.ImagePullSecrets.GetHashCode();
                if (this.NodeSelector != null)
                    hashCode = hashCode * 59 + this.NodeSelector.GetHashCode();
                if (this.OnExit != null)
                    hashCode = hashCode * 59 + this.OnExit.GetHashCode();
                if (this.Parallelism != null)
                    hashCode = hashCode * 59 + this.Parallelism.GetHashCode();
                if (this.PodGC != null)
                    hashCode = hashCode * 59 + this.PodGC.GetHashCode();
                if (this.PodPriority != null)
                    hashCode = hashCode * 59 + this.PodPriority.GetHashCode();
                if (this.PodPriorityClassName != null)
                    hashCode = hashCode * 59 + this.PodPriorityClassName.GetHashCode();
                if (this.Priority != null)
                    hashCode = hashCode * 59 + this.Priority.GetHashCode();
                if (this.SchedulerName != null)
                    hashCode = hashCode * 59 + this.SchedulerName.GetHashCode();
                if (this.SecurityContext != null)
                    hashCode = hashCode * 59 + this.SecurityContext.GetHashCode();
                if (this.ServiceAccountName != null)
                    hashCode = hashCode * 59 + this.ServiceAccountName.GetHashCode();
                if (this.Suspend != null)
                    hashCode = hashCode * 59 + this.Suspend.GetHashCode();
                if (this.Templates != null)
                    hashCode = hashCode * 59 + this.Templates.GetHashCode();
                if (this.Tolerations != null)
                    hashCode = hashCode * 59 + this.Tolerations.GetHashCode();
                if (this.TtlSecondsAfterFinished != null)
                    hashCode = hashCode * 59 + this.TtlSecondsAfterFinished.GetHashCode();
                if (this.VolumeClaimTemplates != null)
                    hashCode = hashCode * 59 + this.VolumeClaimTemplates.GetHashCode();
                if (this.Volumes != null)
                    hashCode = hashCode * 59 + this.Volumes.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}
