/* 
 * Argo
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v2.4.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.IO;
using System.Linq;
using System.Runtime.Serialization;
using System.Text;
using Newtonsoft.Json;

namespace AutoDeploy.ArgoSupport.Workflows.Model
{
    /// <summary>
    /// Template is a reusable and composable unit of execution in a workflow
    /// </summary>
    [DataContract]
    public partial class ArgoTemplate :  IEquatable<ArgoTemplate>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ArgoTemplate" /> class.
        /// </summary>
        [JsonConstructor]
        protected ArgoTemplate() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="ArgoTemplate" /> class.
        /// </summary>
        /// <param name="activeDeadlineSeconds">Optional duration in seconds relative to the StartTime that the pod may be active on a node before the system actively tries to terminate the pod; value must be positive integer This field is only applicable to container and script templates..</param>
        /// <param name="affinity">Affinity sets the pod&#39;s scheduling constraints Overrides the affinity set at the workflow level (if any).</param>
        /// <param name="archiveLocation">Location in which all files related to the step will be stored (logs, artifacts, etc...). Can be overridden by individual items in Outputs. If omitted, will use the default artifact repository location configured in the controller, appended with the &lt;workflowname&gt;/&lt;nodename&gt; in the key..</param>
        /// <param name="arguments">Arguments hold arguments to the template..</param>
        /// <param name="container">Container is the main container image to run in the pod.</param>
        /// <param name="daemon">Deamon will allow a workflow to proceed to the next step so long as the container reaches readiness.</param>
        /// <param name="dag">DAG template subtype which runs a DAG.</param>
        /// <param name="hostAliases">HostAliases is an optional list of hosts and IPs that will be injected into the pod spec.</param>
        /// <param name="initContainers">InitContainers is a list of containers which run before the main container..</param>
        /// <param name="inputs">Inputs describe what inputs parameters and artifacts are supplied to this template.</param>
        /// <param name="metadata">Metdata sets the pods&#39;s metadata, i.e. annotations and labels.</param>
        /// <param name="name">Name is the name of the template (required).</param>
        /// <param name="nodeSelector">NodeSelector is a selector to schedule this step of the workflow to be run on the selected node(s). Overrides the selector set at the workflow level..</param>
        /// <param name="outputs">Outputs describe the parameters and artifacts that this template produces.</param>
        /// <param name="parallelism">Parallelism limits the max total parallel pods that can execute at the same time within the boundaries of this template invocation. If additional steps/dag templates are invoked, the pods created by those templates will not be counted towards this total..</param>
        /// <param name="priority">Priority to apply to workflow pods..</param>
        /// <param name="priorityClassName">PriorityClassName to apply to workflow pods..</param>
        /// <param name="resource">Resource template subtype which can run k8s resources.</param>
        /// <param name="retryStrategy">RetryStrategy describes how to retry a template when it fails.</param>
        /// <param name="schedulerName">If specified, the pod will be dispatched by specified scheduler. Or it will be dispatched by workflow scope scheduler if specified. If neither specified, the pod will be dispatched by default scheduler..</param>
        /// <param name="script">Script runs a portion of code against an interpreter.</param>
        /// <param name="securityContext">SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults to empty.  See type description for default values of each field..</param>
        /// <param name="serviceAccountName">ServiceAccountName to apply to workflow pods.</param>
        /// <param name="sidecars">Sidecars is a list of containers which run alongside the main container Sidecars are automatically killed when the main container completes.</param>
        /// <param name="steps">Steps define a series of sequential/parallel workflow steps.</param>
        /// <param name="suspend">Suspend template subtype which can suspend a workflow when reaching the step.</param>
        /// <param name="template">Template is the name of the template which is used as the base of this template..</param>
        /// <param name="templateRef">TemplateRef is the reference to the template resource which is used as the base of this template..</param>
        /// <param name="tolerations">Tolerations to apply to workflow pods..</param>
        /// <param name="volumes">Volumes is a list of volumes that can be mounted by containers in a template..</param>
        public ArgoTemplate(long? activeDeadlineSeconds = default(long?), k8s.Models.V1Affinity affinity = default(k8s.Models.V1Affinity), ArgoArtifactLocation archiveLocation = default(ArgoArtifactLocation), ArgoArguments arguments = default(ArgoArguments), k8s.Models.V1Container container = default(k8s.Models.V1Container), bool? daemon = default(bool?), ArgoDAGTemplate dag = default(ArgoDAGTemplate), List<k8s.Models.V1HostAlias> hostAliases = default(List<k8s.Models.V1HostAlias>), List<ArgoUserContainer> initContainers = default(List<ArgoUserContainer>), ArgoInputs inputs = default(ArgoInputs), ArgoMetadata metadata = default(ArgoMetadata), string name = default(string), Dictionary<string, string> nodeSelector = default(Dictionary<string, string>), ArgoOutputs outputs = default(ArgoOutputs), long? parallelism = default(long?), int? priority = default(int?), string priorityClassName = default(string), ArgoResourceTemplate resource = default(ArgoResourceTemplate), ArgoRetryStrategy retryStrategy = default(ArgoRetryStrategy), string schedulerName = default(string), ArgoScriptTemplate script = default(ArgoScriptTemplate), k8s.Models.V1PodSecurityContext securityContext = default(k8s.Models.V1PodSecurityContext), string serviceAccountName = default(string), List<ArgoUserContainer> sidecars = default(List<ArgoUserContainer>), List<List<ArgoWorkflowStep>> steps = default(List<List<ArgoWorkflowStep>>), ArgoSuspendTemplate suspend = default(ArgoSuspendTemplate), string template = default(string), ArgoTemplateRef templateRef = default(ArgoTemplateRef), List<k8s.Models.V1Toleration> tolerations = default(List<k8s.Models.V1Toleration>), List<k8s.Models.V1Volume> volumes = default(List<k8s.Models.V1Volume>))
        {
            // to ensure "name" is required (not null)
            if (name == null)
            {
                throw new InvalidDataException("name is a required property for ArgoTemplate and cannot be null");
            }
            else
            {
                this.Name = name;
            }
            this.ActiveDeadlineSeconds = activeDeadlineSeconds;
            this.Affinity = affinity;
            this.ArchiveLocation = archiveLocation;
            this.Arguments = arguments;
            this.Container = container;
            this.Daemon = daemon;
            this.Dag = dag;
            this.HostAliases = hostAliases;
            this.InitContainers = initContainers;
            this.Inputs = inputs;
            this.Metadata = metadata;
            this.NodeSelector = nodeSelector;
            this.Outputs = outputs;
            this.Parallelism = parallelism;
            this.Priority = priority;
            this.PriorityClassName = priorityClassName;
            this.Resource = resource;
            this.RetryStrategy = retryStrategy;
            this.SchedulerName = schedulerName;
            this.Script = script;
            this.SecurityContext = securityContext;
            this.ServiceAccountName = serviceAccountName;
            this.Sidecars = sidecars;
            this.Steps = steps;
            this.Suspend = suspend;
            this.Template = template;
            this.TemplateRef = templateRef;
            this.Tolerations = tolerations;
            this.Volumes = volumes;
        }
        
        /// <summary>
        /// Optional duration in seconds relative to the StartTime that the pod may be active on a node before the system actively tries to terminate the pod; value must be positive integer This field is only applicable to container and script templates.
        /// </summary>
        /// <value>Optional duration in seconds relative to the StartTime that the pod may be active on a node before the system actively tries to terminate the pod; value must be positive integer This field is only applicable to container and script templates.</value>
        [DataMember(Name="activeDeadlineSeconds", EmitDefaultValue=false)]
        public long? ActiveDeadlineSeconds { get; set; }

        /// <summary>
        /// Affinity sets the pod&#39;s scheduling constraints Overrides the affinity set at the workflow level (if any)
        /// </summary>
        /// <value>Affinity sets the pod&#39;s scheduling constraints Overrides the affinity set at the workflow level (if any)</value>
        [DataMember(Name="affinity", EmitDefaultValue=false)]
        public k8s.Models.V1Affinity Affinity { get; set; }

        /// <summary>
        /// Location in which all files related to the step will be stored (logs, artifacts, etc...). Can be overridden by individual items in Outputs. If omitted, will use the default artifact repository location configured in the controller, appended with the &lt;workflowname&gt;/&lt;nodename&gt; in the key.
        /// </summary>
        /// <value>Location in which all files related to the step will be stored (logs, artifacts, etc...). Can be overridden by individual items in Outputs. If omitted, will use the default artifact repository location configured in the controller, appended with the &lt;workflowname&gt;/&lt;nodename&gt; in the key.</value>
        [DataMember(Name="archiveLocation", EmitDefaultValue=false)]
        public ArgoArtifactLocation ArchiveLocation { get; set; }

        /// <summary>
        /// Arguments hold arguments to the template.
        /// </summary>
        /// <value>Arguments hold arguments to the template.</value>
        [DataMember(Name="arguments", EmitDefaultValue=false)]
        public ArgoArguments Arguments { get; set; }

        /// <summary>
        /// Container is the main container image to run in the pod
        /// </summary>
        /// <value>Container is the main container image to run in the pod</value>
        [DataMember(Name="container", EmitDefaultValue=false)]
        public k8s.Models.V1Container Container { get; set; }

        /// <summary>
        /// Deamon will allow a workflow to proceed to the next step so long as the container reaches readiness
        /// </summary>
        /// <value>Deamon will allow a workflow to proceed to the next step so long as the container reaches readiness</value>
        [DataMember(Name="daemon", EmitDefaultValue=false)]
        public bool? Daemon { get; set; }

        /// <summary>
        /// DAG template subtype which runs a DAG
        /// </summary>
        /// <value>DAG template subtype which runs a DAG</value>
        [DataMember(Name="dag", EmitDefaultValue=false)]
        public ArgoDAGTemplate Dag { get; set; }

        /// <summary>
        /// HostAliases is an optional list of hosts and IPs that will be injected into the pod spec
        /// </summary>
        /// <value>HostAliases is an optional list of hosts and IPs that will be injected into the pod spec</value>
        [DataMember(Name="hostAliases", EmitDefaultValue=false)]
        public List<k8s.Models.V1HostAlias> HostAliases { get; set; }

        /// <summary>
        /// InitContainers is a list of containers which run before the main container.
        /// </summary>
        /// <value>InitContainers is a list of containers which run before the main container.</value>
        [DataMember(Name="initContainers", EmitDefaultValue=false)]
        public List<ArgoUserContainer> InitContainers { get; set; }

        /// <summary>
        /// Inputs describe what inputs parameters and artifacts are supplied to this template
        /// </summary>
        /// <value>Inputs describe what inputs parameters and artifacts are supplied to this template</value>
        [DataMember(Name="inputs", EmitDefaultValue=false)]
        public ArgoInputs Inputs { get; set; }

        /// <summary>
        /// Metdata sets the pods&#39;s metadata, i.e. annotations and labels
        /// </summary>
        /// <value>Metdata sets the pods&#39;s metadata, i.e. annotations and labels</value>
        [DataMember(Name="metadata", EmitDefaultValue=false)]
        public ArgoMetadata Metadata { get; set; }

        /// <summary>
        /// Name is the name of the template
        /// </summary>
        /// <value>Name is the name of the template</value>
        [DataMember(Name="name", EmitDefaultValue=false)]
        public string Name { get; set; }

        /// <summary>
        /// NodeSelector is a selector to schedule this step of the workflow to be run on the selected node(s). Overrides the selector set at the workflow level.
        /// </summary>
        /// <value>NodeSelector is a selector to schedule this step of the workflow to be run on the selected node(s). Overrides the selector set at the workflow level.</value>
        [DataMember(Name="nodeSelector", EmitDefaultValue=false)]
        public Dictionary<string, string> NodeSelector { get; set; }

        /// <summary>
        /// Outputs describe the parameters and artifacts that this template produces
        /// </summary>
        /// <value>Outputs describe the parameters and artifacts that this template produces</value>
        [DataMember(Name="outputs", EmitDefaultValue=false)]
        public ArgoOutputs Outputs { get; set; }

        /// <summary>
        /// Parallelism limits the max total parallel pods that can execute at the same time within the boundaries of this template invocation. If additional steps/dag templates are invoked, the pods created by those templates will not be counted towards this total.
        /// </summary>
        /// <value>Parallelism limits the max total parallel pods that can execute at the same time within the boundaries of this template invocation. If additional steps/dag templates are invoked, the pods created by those templates will not be counted towards this total.</value>
        [DataMember(Name="parallelism", EmitDefaultValue=false)]
        public long? Parallelism { get; set; }

        /// <summary>
        /// Priority to apply to workflow pods.
        /// </summary>
        /// <value>Priority to apply to workflow pods.</value>
        [DataMember(Name="priority", EmitDefaultValue=false)]
        public int? Priority { get; set; }

        /// <summary>
        /// PriorityClassName to apply to workflow pods.
        /// </summary>
        /// <value>PriorityClassName to apply to workflow pods.</value>
        [DataMember(Name="priorityClassName", EmitDefaultValue=false)]
        public string PriorityClassName { get; set; }

        /// <summary>
        /// Resource template subtype which can run k8s resources
        /// </summary>
        /// <value>Resource template subtype which can run k8s resources</value>
        [DataMember(Name="resource", EmitDefaultValue=false)]
        public ArgoResourceTemplate Resource { get; set; }

        /// <summary>
        /// RetryStrategy describes how to retry a template when it fails
        /// </summary>
        /// <value>RetryStrategy describes how to retry a template when it fails</value>
        [DataMember(Name="retryStrategy", EmitDefaultValue=false)]
        public ArgoRetryStrategy RetryStrategy { get; set; }

        /// <summary>
        /// If specified, the pod will be dispatched by specified scheduler. Or it will be dispatched by workflow scope scheduler if specified. If neither specified, the pod will be dispatched by default scheduler.
        /// </summary>
        /// <value>If specified, the pod will be dispatched by specified scheduler. Or it will be dispatched by workflow scope scheduler if specified. If neither specified, the pod will be dispatched by default scheduler.</value>
        [DataMember(Name="schedulerName", EmitDefaultValue=false)]
        public string SchedulerName { get; set; }

        /// <summary>
        /// Script runs a portion of code against an interpreter
        /// </summary>
        /// <value>Script runs a portion of code against an interpreter</value>
        [DataMember(Name="script", EmitDefaultValue=false)]
        public ArgoScriptTemplate Script { get; set; }

        /// <summary>
        /// SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults to empty.  See type description for default values of each field.
        /// </summary>
        /// <value>SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults to empty.  See type description for default values of each field.</value>
        [DataMember(Name="securityContext", EmitDefaultValue=false)]
        public k8s.Models.V1PodSecurityContext SecurityContext { get; set; }

        /// <summary>
        /// ServiceAccountName to apply to workflow pods
        /// </summary>
        /// <value>ServiceAccountName to apply to workflow pods</value>
        [DataMember(Name="serviceAccountName", EmitDefaultValue=false)]
        public string ServiceAccountName { get; set; }

        /// <summary>
        /// Sidecars is a list of containers which run alongside the main container Sidecars are automatically killed when the main container completes
        /// </summary>
        /// <value>Sidecars is a list of containers which run alongside the main container Sidecars are automatically killed when the main container completes</value>
        [DataMember(Name="sidecars", EmitDefaultValue=false)]
        public List<ArgoUserContainer> Sidecars { get; set; }

        /// <summary>
        /// Steps define a series of sequential/parallel workflow steps
        /// </summary>
        /// <value>Steps define a series of sequential/parallel workflow steps</value>
        [DataMember(Name="steps", EmitDefaultValue=false)]
        public List<List<ArgoWorkflowStep>> Steps { get; set; }

        /// <summary>
        /// Suspend template subtype which can suspend a workflow when reaching the step
        /// </summary>
        /// <value>Suspend template subtype which can suspend a workflow when reaching the step</value>
        [DataMember(Name="suspend", EmitDefaultValue=false)]
        public ArgoSuspendTemplate Suspend { get; set; }

        /// <summary>
        /// Template is the name of the template which is used as the base of this template.
        /// </summary>
        /// <value>Template is the name of the template which is used as the base of this template.</value>
        [DataMember(Name="template", EmitDefaultValue=false)]
        public string Template { get; set; }

        /// <summary>
        /// TemplateRef is the reference to the template resource which is used as the base of this template.
        /// </summary>
        /// <value>TemplateRef is the reference to the template resource which is used as the base of this template.</value>
        [DataMember(Name="templateRef", EmitDefaultValue=false)]
        public ArgoTemplateRef TemplateRef { get; set; }

        /// <summary>
        /// Tolerations to apply to workflow pods.
        /// </summary>
        /// <value>Tolerations to apply to workflow pods.</value>
        [DataMember(Name="tolerations", EmitDefaultValue=false)]
        public List<k8s.Models.V1Toleration> Tolerations { get; set; }

        /// <summary>
        /// Volumes is a list of volumes that can be mounted by containers in a template.
        /// </summary>
        /// <value>Volumes is a list of volumes that can be mounted by containers in a template.</value>
        [DataMember(Name="volumes", EmitDefaultValue=false)]
        public List<k8s.Models.V1Volume> Volumes { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class ArgoTemplate {\n");
            sb.Append("  ActiveDeadlineSeconds: ").Append(ActiveDeadlineSeconds).Append("\n");
            sb.Append("  Affinity: ").Append(Affinity).Append("\n");
            sb.Append("  ArchiveLocation: ").Append(ArchiveLocation).Append("\n");
            sb.Append("  Arguments: ").Append(Arguments).Append("\n");
            sb.Append("  Container: ").Append(Container).Append("\n");
            sb.Append("  Daemon: ").Append(Daemon).Append("\n");
            sb.Append("  Dag: ").Append(Dag).Append("\n");
            sb.Append("  HostAliases: ").Append(HostAliases).Append("\n");
            sb.Append("  InitContainers: ").Append(InitContainers).Append("\n");
            sb.Append("  Inputs: ").Append(Inputs).Append("\n");
            sb.Append("  Metadata: ").Append(Metadata).Append("\n");
            sb.Append("  Name: ").Append(Name).Append("\n");
            sb.Append("  NodeSelector: ").Append(NodeSelector).Append("\n");
            sb.Append("  Outputs: ").Append(Outputs).Append("\n");
            sb.Append("  Parallelism: ").Append(Parallelism).Append("\n");
            sb.Append("  Priority: ").Append(Priority).Append("\n");
            sb.Append("  PriorityClassName: ").Append(PriorityClassName).Append("\n");
            sb.Append("  Resource: ").Append(Resource).Append("\n");
            sb.Append("  RetryStrategy: ").Append(RetryStrategy).Append("\n");
            sb.Append("  SchedulerName: ").Append(SchedulerName).Append("\n");
            sb.Append("  Script: ").Append(Script).Append("\n");
            sb.Append("  SecurityContext: ").Append(SecurityContext).Append("\n");
            sb.Append("  ServiceAccountName: ").Append(ServiceAccountName).Append("\n");
            sb.Append("  Sidecars: ").Append(Sidecars).Append("\n");
            sb.Append("  Steps: ").Append(Steps).Append("\n");
            sb.Append("  Suspend: ").Append(Suspend).Append("\n");
            sb.Append("  Template: ").Append(Template).Append("\n");
            sb.Append("  TemplateRef: ").Append(TemplateRef).Append("\n");
            sb.Append("  Tolerations: ").Append(Tolerations).Append("\n");
            sb.Append("  Volumes: ").Append(Volumes).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as ArgoTemplate);
        }

        /// <summary>
        /// Returns true if ArgoTemplate instances are equal
        /// </summary>
        /// <param name="input">Instance of ArgoTemplate to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(ArgoTemplate input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.ActiveDeadlineSeconds == input.ActiveDeadlineSeconds ||
                    (this.ActiveDeadlineSeconds != null &&
                    this.ActiveDeadlineSeconds.Equals(input.ActiveDeadlineSeconds))
                ) && 
                (
                    this.Affinity == input.Affinity ||
                    (this.Affinity != null &&
                    this.Affinity.Equals(input.Affinity))
                ) && 
                (
                    this.ArchiveLocation == input.ArchiveLocation ||
                    (this.ArchiveLocation != null &&
                    this.ArchiveLocation.Equals(input.ArchiveLocation))
                ) && 
                (
                    this.Arguments == input.Arguments ||
                    (this.Arguments != null &&
                    this.Arguments.Equals(input.Arguments))
                ) && 
                (
                    this.Container == input.Container ||
                    (this.Container != null &&
                    this.Container.Equals(input.Container))
                ) && 
                (
                    this.Daemon == input.Daemon ||
                    (this.Daemon != null &&
                    this.Daemon.Equals(input.Daemon))
                ) && 
                (
                    this.Dag == input.Dag ||
                    (this.Dag != null &&
                    this.Dag.Equals(input.Dag))
                ) && 
                (
                    this.HostAliases == input.HostAliases ||
                    this.HostAliases != null &&
                    this.HostAliases.SequenceEqual(input.HostAliases)
                ) && 
                (
                    this.InitContainers == input.InitContainers ||
                    this.InitContainers != null &&
                    this.InitContainers.SequenceEqual(input.InitContainers)
                ) && 
                (
                    this.Inputs == input.Inputs ||
                    (this.Inputs != null &&
                    this.Inputs.Equals(input.Inputs))
                ) && 
                (
                    this.Metadata == input.Metadata ||
                    (this.Metadata != null &&
                    this.Metadata.Equals(input.Metadata))
                ) && 
                (
                    this.Name == input.Name ||
                    (this.Name != null &&
                    this.Name.Equals(input.Name))
                ) && 
                (
                    this.NodeSelector == input.NodeSelector ||
                    this.NodeSelector != null &&
                    this.NodeSelector.SequenceEqual(input.NodeSelector)
                ) && 
                (
                    this.Outputs == input.Outputs ||
                    (this.Outputs != null &&
                    this.Outputs.Equals(input.Outputs))
                ) && 
                (
                    this.Parallelism == input.Parallelism ||
                    (this.Parallelism != null &&
                    this.Parallelism.Equals(input.Parallelism))
                ) && 
                (
                    this.Priority == input.Priority ||
                    (this.Priority != null &&
                    this.Priority.Equals(input.Priority))
                ) && 
                (
                    this.PriorityClassName == input.PriorityClassName ||
                    (this.PriorityClassName != null &&
                    this.PriorityClassName.Equals(input.PriorityClassName))
                ) && 
                (
                    this.Resource == input.Resource ||
                    (this.Resource != null &&
                    this.Resource.Equals(input.Resource))
                ) && 
                (
                    this.RetryStrategy == input.RetryStrategy ||
                    (this.RetryStrategy != null &&
                    this.RetryStrategy.Equals(input.RetryStrategy))
                ) && 
                (
                    this.SchedulerName == input.SchedulerName ||
                    (this.SchedulerName != null &&
                    this.SchedulerName.Equals(input.SchedulerName))
                ) && 
                (
                    this.Script == input.Script ||
                    (this.Script != null &&
                    this.Script.Equals(input.Script))
                ) && 
                (
                    this.SecurityContext == input.SecurityContext ||
                    (this.SecurityContext != null &&
                    this.SecurityContext.Equals(input.SecurityContext))
                ) && 
                (
                    this.ServiceAccountName == input.ServiceAccountName ||
                    (this.ServiceAccountName != null &&
                    this.ServiceAccountName.Equals(input.ServiceAccountName))
                ) && 
                (
                    this.Sidecars == input.Sidecars ||
                    this.Sidecars != null &&
                    this.Sidecars.SequenceEqual(input.Sidecars)
                ) && 
                (
                    this.Steps == input.Steps ||
                    this.Steps != null &&
                    this.Steps.SequenceEqual(input.Steps)
                ) && 
                (
                    this.Suspend == input.Suspend ||
                    (this.Suspend != null &&
                    this.Suspend.Equals(input.Suspend))
                ) && 
                (
                    this.Template == input.Template ||
                    (this.Template != null &&
                    this.Template.Equals(input.Template))
                ) && 
                (
                    this.TemplateRef == input.TemplateRef ||
                    (this.TemplateRef != null &&
                    this.TemplateRef.Equals(input.TemplateRef))
                ) && 
                (
                    this.Tolerations == input.Tolerations ||
                    this.Tolerations != null &&
                    this.Tolerations.SequenceEqual(input.Tolerations)
                ) && 
                (
                    this.Volumes == input.Volumes ||
                    this.Volumes != null &&
                    this.Volumes.SequenceEqual(input.Volumes)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.ActiveDeadlineSeconds != null)
                    hashCode = hashCode * 59 + this.ActiveDeadlineSeconds.GetHashCode();
                if (this.Affinity != null)
                    hashCode = hashCode * 59 + this.Affinity.GetHashCode();
                if (this.ArchiveLocation != null)
                    hashCode = hashCode * 59 + this.ArchiveLocation.GetHashCode();
                if (this.Arguments != null)
                    hashCode = hashCode * 59 + this.Arguments.GetHashCode();
                if (this.Container != null)
                    hashCode = hashCode * 59 + this.Container.GetHashCode();
                if (this.Daemon != null)
                    hashCode = hashCode * 59 + this.Daemon.GetHashCode();
                if (this.Dag != null)
                    hashCode = hashCode * 59 + this.Dag.GetHashCode();
                if (this.HostAliases != null)
                    hashCode = hashCode * 59 + this.HostAliases.GetHashCode();
                if (this.InitContainers != null)
                    hashCode = hashCode * 59 + this.InitContainers.GetHashCode();
                if (this.Inputs != null)
                    hashCode = hashCode * 59 + this.Inputs.GetHashCode();
                if (this.Metadata != null)
                    hashCode = hashCode * 59 + this.Metadata.GetHashCode();
                if (this.Name != null)
                    hashCode = hashCode * 59 + this.Name.GetHashCode();
                if (this.NodeSelector != null)
                    hashCode = hashCode * 59 + this.NodeSelector.GetHashCode();
                if (this.Outputs != null)
                    hashCode = hashCode * 59 + this.Outputs.GetHashCode();
                if (this.Parallelism != null)
                    hashCode = hashCode * 59 + this.Parallelism.GetHashCode();
                if (this.Priority != null)
                    hashCode = hashCode * 59 + this.Priority.GetHashCode();
                if (this.PriorityClassName != null)
                    hashCode = hashCode * 59 + this.PriorityClassName.GetHashCode();
                if (this.Resource != null)
                    hashCode = hashCode * 59 + this.Resource.GetHashCode();
                if (this.RetryStrategy != null)
                    hashCode = hashCode * 59 + this.RetryStrategy.GetHashCode();
                if (this.SchedulerName != null)
                    hashCode = hashCode * 59 + this.SchedulerName.GetHashCode();
                if (this.Script != null)
                    hashCode = hashCode * 59 + this.Script.GetHashCode();
                if (this.SecurityContext != null)
                    hashCode = hashCode * 59 + this.SecurityContext.GetHashCode();
                if (this.ServiceAccountName != null)
                    hashCode = hashCode * 59 + this.ServiceAccountName.GetHashCode();
                if (this.Sidecars != null)
                    hashCode = hashCode * 59 + this.Sidecars.GetHashCode();
                if (this.Steps != null)
                    hashCode = hashCode * 59 + this.Steps.GetHashCode();
                if (this.Suspend != null)
                    hashCode = hashCode * 59 + this.Suspend.GetHashCode();
                if (this.Template != null)
                    hashCode = hashCode * 59 + this.Template.GetHashCode();
                if (this.TemplateRef != null)
                    hashCode = hashCode * 59 + this.TemplateRef.GetHashCode();
                if (this.Tolerations != null)
                    hashCode = hashCode * 59 + this.Tolerations.GetHashCode();
                if (this.Volumes != null)
                    hashCode = hashCode * 59 + this.Volumes.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}
